<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【基础算法】(02) 十二种排序算法（第二篇）]]></title>
    <url>%2Fblog%2F2018%2F06%2F01%2Falgorithm-02%2F</url>
    <content type="text"><![CDATA[【基础算法】(02) 十二种排序算法（第二篇）1. 篇述本系列总结了常用的十二种排序算法，每个算法都包括算法原理, 代码实现, 面试例题 三部分。 其中本文是排序算法系列的第二篇，介绍了： 5.选择排序—简单选择排序（Simple Selection Sort） 6.选择排序—堆排序（Heap Sort） 7.交换排序—冒泡排序（Bubble Sort） 8.鸡尾酒排序/双向冒泡排序 2. 直接插入排序 (Straight Insertion Sort)3. 二分插入排序 （Binary insert sort)4. 希尔排序 （Shell’s Sort）参见第一篇 5. 选择排序—简单选择排序（Simple Selection Sort）5.1 原理简介选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换； 第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换； 第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换； 直到整个序列按关键码有序。 5.2 代码实现12345678910111213141516171819void selection_sort(int *a, int len) &#123; register int i, j, min, t; for(i = 0; i &lt; len - 1; i ++) &#123; min = i; //查找最小值 for(j = i + 1; j &lt; len; j ++) if(a[min] &gt; a[j]) min = j; //交换 if(min != i) &#123; t = a[min]; a[min] = a[i]; a[i] = t; &#125; &#125; &#125; 6. 选择排序—堆排序（Heap Sort）6.1 原理简介堆排序（Heap sort）堆排序是一种树形选择排序，是对直接选择排序的有效改进。 堆排序利用堆数据结构。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 6.1.1 什么是堆？我们这里提到的堆一般都指的是二叉堆，它满足二个特性： 父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值; 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。 初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。 因此，实现堆排序需解决两个问题： 如何将n 个待排序的数建成堆； 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。6.1.2 首先讨论第二个问题输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。 调整小顶堆的方法： 设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。 将根结点与左、右子树中较小元素的进行交换。 若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法（2）. 若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）. 继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。 称这个自根结点到叶子结点的调整过程为筛选。 6.1.3 再讨论对n 个元素初始建堆的过程建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。 n 个结点的完全二叉树，则最后一个结点是第[ n/2 ]个结点的子树。 筛选从第[ n/2 ]个结点为根的子树开始，该子树成为堆。 之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。 6.2 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void print(int a[], int n)&#123; for(int j= 0; j&lt;n; j++)&#123; cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; /** * 已知H[s…m]除了H[s] 外均满足堆的定义 * 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选, * @param H是待调整的堆数组 * @param s是待调整的数组元素的位置 * @param length是数组的长度 */ void HeapAdjust(int H[],int s, int length) &#123; int tmp = H[s]; int child = 2*s+1; //左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置) while (child &lt; length) &#123; if(child+1 &lt;length &amp;&amp; H[child]&lt;H[child+1]) &#123; // 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点) ++child ; &#125; if(H[s]&lt;H[child]) &#123; // 如果较大的子结点大于父结点 H[s] = H[child]; // 那么把较大的子结点往上移动，替换它的父结点 s = child; // 重新设置s ,即待调整的下一个结点的位置 child = 2*s+1; &#125; else &#123; // 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出 break; &#125; H[s] = tmp; // 当前待调整的结点放到比其大的孩子结点位置上 &#125; print(H,length); &#125; /** * 初始堆进行调整 * 将H[0..length-1]建成堆 * 调整完之后第一个元素是序列的最小的元素 */ void BuildingHeap(int H[], int length) &#123; //最后一个有孩子的节点的位置 i= (length -1) / 2 for (int i = (length -1) / 2 ; i &gt;= 0; --i) HeapAdjust(H,i,length); &#125; /** * 堆排序算法 */ void HeapSort(int H[],int length) &#123; //初始堆 BuildingHeap(H, length); //从最后一个元素开始对序列进行调整 for (int i = length - 1; i &gt; 0; --i) &#123; //交换堆顶元素H[0]和堆中最后一个元素 int temp = H[i]; H[i] = H[0]; H[0] = temp; //每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整 HeapAdjust(H,0,i); &#125; &#125; int main()&#123; int H[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;; cout&lt;&lt;&quot;初始值：&quot;; print(H,10); HeapSort(H,10); //selectSort(a, 8); cout&lt;&lt;&quot;结果：&quot;; print(H,10); &#125; 交换排序—冒泡排序（Bubble Sort）7.1 原理简介冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 算法描述： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 7.2 代码实现123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt; void bubbleSort(int arr[], int count) &#123; int i = count, j; int temp; while(i &gt; 0) &#123; for(j = 0; j &lt; i - 1; j++) &#123; if(arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; i--; &#125; &#125; int main() &#123; //测试数据 int arr[] = &#123;5, 4, 1, 3, 6&#125;; //冒泡排序 bubbleSort(arr, 5); //打印排序结果 int i; for(i = 0; i &lt; 5; i++) printf(&quot;%4d&quot;, arr[i]); &#125; 7.3 冒泡排序算法的改进对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 123456789101112void Bubble_1 ( int r[], int n) &#123; int i= n -1; //初始时,最后位置保持不变 while ( i&gt; 0) &#123; int pos= 0; //每趟开始时,无记录交换 for (int j= 0; j&lt; i; j++) if (r[j]&gt; r[j+1]) &#123; pos= j; //记录交换的位置 int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp; &#125; i= pos; //为下一趟排序作准备 &#125; &#125; 第二种优化算法参见 [ 8. 鸡尾酒排序/双向冒泡排序 ]。 8. 鸡尾酒排序/双向冒泡排序8.1 原理简介鸡尾酒排序等于是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。 算法描述和分析： 依次比较相邻的两个数，将小数放在前面，大数放在后面； 第一趟可得到：将最大数放到最后一位。 第二趟可得到：将第二大的数放到倒数第二位。 如此下去，重复以上过程，直至最终完成排序。 8.2 代码实现123456789101112131415161718192021222324252627void CocktailSort(int *a,int nsize) &#123; int tail=nsize-1; for (int i=0;i&lt;tail;) &#123; for (int j=tail;j&gt;i;--j) //第一轮，先将最小的数据排到前面 &#123; if (a[j]&lt;a[j-1]) &#123; int temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; &#125; &#125; ++i; //原来i处数据已排好序，加1 for (j=i;j&lt;tail;++j) //第二轮，将最大的数据排到后面 &#123; if (a[j]&gt;a[j+1]) &#123; int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; tail--; //原tail处数据也已排好序，将其减1 &#125; &#125; 9. 交换排序—快速排序（Quick Sort）10. 归并排序（Merge Sort）11. 桶排序 (Bucket sort)12. 计数排序 (Counting sort)13. 基数排序 (Radix Sort)参见第三、四篇 14. 总结]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【基础算法】(01) 十二种排序算法（第一篇）]]></title>
    <url>%2Fblog%2F2018%2F05%2F31%2Falgorithm-01%2F</url>
    <content type="text"><![CDATA[【基础算法】(01) 十二种排序算法（第一篇）1. 总述本系列总结了常用的十二种排序算法，每个算法都包括算法原理, 代码实现, 面试例题 三部分。 其中本文是排序算法系列的第一篇，介绍了三种插入排序方法： 2.直接插入排序 (Straight Insertion Sort) 3.二分插入排序 （Binary Insert Sort), 4.希尔排序 （Shell’s Sort） 2. 直接插入排序 (Straight Insertion Sort)2.1 原理简介插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 算法描述和分析: 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序; 取出下一个元素，在已经排序的元素序列中从后向前扫描; 如果该元素（已排序）大于新元素，将该元素移到下一位置; 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置; 将新元素插入到该位置后; 重复步骤2~5。2.2 代码实现123456789101112131415161718192021222324252627282930void print(int a[], int n ,int i)&#123; cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j++)&#123; cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; void InsertSort(int a[], int n) &#123; for(int i= 1; i&lt;n; i++)&#123; if(a[i] &lt; a[i-1])&#123; //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 int j= i-1; int x = a[i]; //复制为哨兵，即存储待排序元素 a[i] = a[i-1]; //先后移一个元素 while(x &lt; a[j])&#123; //查找在有序表的插入位置 a[j+1] = a[j]; j--; //元素后移 &#125; a[j+1] = x; //插入到正确位置 &#125; print(a,n,i); //打印每趟排序的结果 &#125; &#125; int main()&#123; int a[8] = &#123;3,1,5,7,2,4,9,6&#125;; InsertSort(a,8); print(a,8,8); &#125; 3. 二分插入排序 （Binary insert sort)二分（折半）插入（Binary insert sort)排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。 3.1 原理简介一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序; 取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置; 将新元素插入到该位置后; 重复上述两步。 二分插入排序是一种稳定的排序。当n较大时，总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。 3.2 代码实现1234567891011121314151617181920212223void BinInsertSort(int a[], int n) &#123; int key, left, right, middle; for (int i=1; i&lt;n; i++) &#123; key = a[i]; left = 0; right = i-1; while (left&lt;=right) &#123; middle = (left+right)/2; if (a[middle]&gt;key) right = middle-1; else left = middle+1; &#125; for(int j=i-1; j&gt;=left; j--) &#123; a[j+1] = a[j]; &#125; a[left] = key; &#125; &#125; 4. 希尔（Shell）排序希尔排序（Shell`s Sort）相对直接排序有较大的改进。希尔排序又叫缩小增量排序。 4.1 原理简介 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void print(int a[], int n ,int i)&#123; cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j++)&#123; cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; /** * 直接插入排序的一般形式 * @param int dk 缩小增量，如果是直接插入排序，dk=1 */ void ShellInsertSort(int a[], int n, int dk) &#123; for(int i= dk; i&lt;n; ++i)&#123; if(a[i] &lt; a[i-dk])&#123; //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 int j = i-dk; int x = a[i]; //复制为哨兵，即存储待排序元素 a[i] = a[i-dk]; //首先后移一个元素 while(x &lt; a[j])&#123; //查找在有序表的插入位置 a[j+dk] = a[j]; j -= dk; //元素后移 &#125; a[j+dk] = x; //插入到正确位置 &#125; print(a, n,i ); &#125; &#125; /** * 先按增量d（n/2,n为要排序数的个数进行希尔排序 */ void shellSort(int a[], int n)&#123; int dk = n/2; while( dk &gt;= 1 )&#123; ShellInsertSort(a, n, dk); dk = dk/2; &#125; &#125; int main()&#123; int a[8] = &#123;3,1,5,7,2,4,9,6&#125;; //ShellInsertSort(a,8,1); //直接插入排序 shellSort(a,8); //希尔插入排序 print(a,8,8); &#125; 希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的。 但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。 希尔排序方法是一个不稳定的排序方法。 5. 选择排序—简单选择排序（Simple Selection Sort）6. 选择排序—堆排序（Heap Sort）7. 交换排序—冒泡排序（Bubble Sort）8. 鸡尾酒排序/双向冒泡排序9. 交换排序—快速排序（Quick Sort）10. 归并排序（Merge Sort）11. 桶排序 (Bucket sort)12. 计数排序 (Counting sort)13. 基数排序 (Radix Sort)参见第二、三、四篇 14. 总结]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2Fblog%2F2017%2F12%2F30%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[Welcome to my blog!欢迎来到我的博客！博客新开张，请多多指教。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
</search>
